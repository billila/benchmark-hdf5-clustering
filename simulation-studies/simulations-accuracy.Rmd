---
title: "Simulation study: Assessing accuracy"
author: "Stephanie Hicks"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
   html_document:
        toc: true
        toc_float: true
        highlight: tango
        number_sections: true
---

# Summary

In this set of simulations, we simulate a mixture of gaussian 
distributions for cells from three clusters. We are assessing
the accuracy of _k_-means and `mbkmeans()`. 

# Workspace Setup

```{r, wkspace-setup, results='hide', message=FALSE, warning=FALSE}
library(mbkmeans)
library(ClusterR)
library(SummarizedBenchmark)
library(parallel)
```

Simulate a mixture of gaussian data for cells from 
three clusters. 
```{r}
ncells <- 1000  # Number of cells

# Our simulation involves three cell types/components.
# Cells are distributed according to a bivariate normal in a 2-D biological subspace. 
# Each cell type has a different x/y center and a different SD.

xmus <- c(0,5,5)
xsds <- c(1,0.1,1)
ymus <- c(5,5,0)
ysds <- c(1,0.1,1)

prop1 <- c(0.3,0.5,0.2)
comp1 <- sample(1:3, prob=prop1, size=ncells, replace=TRUE)

# Sampling locations for cells in each component.
set.seed(0)
samples1 <- cbind(rnorm(n=ncells, mean=xmus[comp1],sd=xsds[comp1]),
                  rnorm(n=ncells, mean=ymus[comp1],sd=ysds[comp1]))
    
# Plot the true cluster locations
ref.cols <- c("blue", "brown1", "gold2")
clust1 <- ref.cols[comp1]
plot(samples1, pch=16, cex=1.5, col=clust1, main=paste0("True clusters"))

# Random projection to D dimensional space, to mimic high-dimensional expression data.
ngenes <- 100
set.seed(0)
proj <- matrix(rnorm(ngenes*ncells), nrow=ngenes, ncol=2)
A1 <- samples1 %*% t(proj)

# Add normally distributed noise.
A1 <- A1 + rnorm(ngenes*ncells)
rownames(A1) <- paste0("Cell", seq_len(ncells), "-1")
colnames(A1) <- paste0("Gene", seq_len(ngenes))
```

# Benchmark clustering methods 

## Using SummarizedBenchmark framework

Testing out using `SummarizedBenchmark` for 
benchmarking. 

```{r}
bd <- BenchDesign(data = list(obs_data=matrix(A1),
                              status = comp1))

bd <- bd %>%
    addMethod(label = "kmeans",
              func = kmeans,
              params = rlang::quos(x = obs_data,
                                   centers = 3))

sb1 <- buildBench(bd, truthCols = "status")
sb1 <- addPerformanceMetric( sb, 
                            evalMetric=c("adjustedRandIndex"),
                            assay="status" )
names(performanceMetrics(sb)[["status"]])
```


## Using a classic framework

```{r}
# stats::kmeans 
cl <- status::kmeans(A1, centers=3)
table(cl$cluster,comp1)
ari_kmeans <- mclust::adjustedRandIndex(cl$cluster,comp1)

# ClusterR::MiniBatchKmeans
ClusterR::MiniBatchKmeans

# mbkmeans::mini_batch
cl_mbkmeans <- mini_batch(A1, clusters = 3, 
                batch_size = 10, num_init = 10, 
                max_iters = 100,init_fraction = .1,
                initializer = "random")
table(cl_mbkmeans$Clusters,comp1)
ari_mbkmeans <- mclust::adjustedRandIndex(cl_mbkmeans$Clusters, comp1)
```
